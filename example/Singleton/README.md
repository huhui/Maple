注意：此单例模式的编写运用了我所封装的Linux网络组件


1  单例模式的目的：确保一个类只有一个实例，并提供对该实例的全局访问。

2  编写时需要注意以下几点：

a) 把构造函数设为私有，且禁用赋值和复制。
   
   存在的问题：单例模式需要有一个实例，现在构造函数设为私有，那么在主函数中连一个对象也无法实例化。

b) 在类中提供一个static指针（可以将static数据成员理解为属于该类的全局变量）
   和static函数（可以将static函数理解为属于该类的全局函数）绕过构造函数为private的限制，
   当然此处我们在外部只用到static函数，之所以要使用static指针，是因为static函数中只能操作static指针。
   
   利用static函数，在堆空间动态实例化一个本类对象。（注意：在类中是无法直接在栈空间静态构建一个本类对象的）
   
   存在的问题：利用static函数可以产生多个对象，而非一个对象。
   
c) 对于static指针，每次先判断是否为NULL。此时实现了一个简单的单例模式。
   
   存在的问题：在多线程环境下产生的对象可能不唯一。
   
d) 引入互斥锁，实现对getInstance内临界区的互斥访问。此时每次调用都需要上锁，导致效率下降。
   
e) 采用double check模式，使得不必每次调用都需要加锁，提高了效率。

4  这种编写单例模式的方法叫做 DCLP（double-check-locking-pattern）。

5  拓展：http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf

6  标准实现代码参看 test_singleton.cpp
